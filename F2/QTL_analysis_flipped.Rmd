---
title: "QTL_analysis_flipped"
output: html_document
---

### purpose of this script is to finish QTL analysis with several LG flipped 

```{r}
### load lib
library(tidyverse)
library(qtl) 
library(snowfall)
library(ggrepel) 
library(Biostrings) 
source("~/KIAT/function_BnRNAseq.R")  

### load data and run scanone & cim
LG.f2.after.crossover <- read.cross("csvsr", genfile = "~/F2/data/QTL_analysis/LG.f2.madmapper.final_gen_revised_flipped.csv",
                     phefile = "~/F2/data/QTL_analysis/F2.pheno.csv",
                     genotypes = c("AA", "AB", "BB")) # the only problem is that 44 phenotypes were read instead of 43, need to figure out why later

plot.map(LG.f2.after.crossover)
map.summary <- summaryMap(LG.f2.after.crossover) # 2884
write.csv(map.summary, file = "~/F2/output/QTL_analysis/map.summary.csv")   

LG.f2.after.crossover <- sim.geno(LG.f2.after.crossover,step=1,n.draws=32) # imputation
LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover,step=1) # calculate the probability of the true underlying genotypes given the observed multipoint marker data --> for each imputed data, give a probability?

sfInit(parallel = TRUE, cpus = 4)
sfExport("LG.f2.after.crossover") 
sfLibrary(qtl)

system.time(
scanone.perm.imp <-
  sfLapply(seq_along(LG.f2.after.crossover$pheno), function(trait){
    print(trait) # print doesn't work in here
    tmp <-scanone(LG.f2.after.crossover,pheno.col = trait, method="imp",n.perm=1000, n.cluster = 16)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes 40 mins to finish
)
sfStop()

names(scanone.perm.imp) <- colnames(LG.f2.after.crossover$pheno)
save(scanone.perm.imp, file = "~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")

# Erucic acid 
scanone.imp.Erucic <- scanone(LG.f2.after.crossover,pheno.col=15,method="imp") #
plot(scanone.imp.Erucic,bandcol="gray90", main="Erucic_acid")
abline(h=scanone.perm.imp[["Erucic_acid"]],lty=2) #add permuation threshold

# Oleic acid
scanone.imp.Oleic <- scanone(LG.f2.after.crossover,pheno.col=8,method="imp") #
plot(scanone.imp.Oleic,bandcol="gray90", main="Oleic_acid")
abline(h=scanone.perm.imp[["Oleic_acid"]],lty=2) #add permuation threshold

system.time(
scanone.imp <-
lapply(seq_along(LG.f2.after.crossover$pheno[1:43]), function(trait) {
  print(trait)
  scanone(LG.f2.after.crossover,pheno.col=trait,method="imp")
})
)
names(scanone.imp) <- colnames(LG.f2.after.crossover$pheno)[1:43]

png("~/F2/output/QTL_analysis/figure/QTL_one_dim_flipped.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(scanone.imp)){
  plot(scanone.imp[[i]],bandcol="gray90", main=i)
  abline(h=scanone.perm.imp[[i]],lty=2)
}

dev.off()

save(scanone.imp, file = "~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.qtl <-
lapply(seq_along(LG.f2.after.crossover$pheno)[1:43], function(trait) {
  print(trait)
  cim(LG.f2.after.crossover, n.marcovar=5, pheno.col=trait,method="em")
})

cim.qtl[["vaccenic_acid"]] 

# here we use the interval mapping method "em" as this is how cim was originaly implmented.the n.marcovar= argument defines the maximum number of marker covariates to use.
names(cim.qtl) <- colnames(LG.f2.after.crossover$pheno)[1:43]

sfInit(parallel = TRUE, cpus = 4)
sfExport("LG.f2.after.crossover")
sfLibrary(qtl)

cim.perm <-
  sfLapply(seq_along(LG.f2.after.crossover$pheno)[1:43], function(trait){
    message(trait) # message doesn't work in here either
    tmp <- cim(LG.f2.after.crossover,
               pheno.col = trait,
               n.marcovar=5,
               method="em",
               n.perm=1000)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes almost 4 hours to finish

sfStop() 

names(cim.perm) <- colnames(LG.f2.after.crossover$pheno)[1:43]

# plot out result and save plot
png("~/F2/output/QTL_analysis/figure/QTL_cim_1_flipped.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(cim.qtl)){
  plot(cim.qtl[[i]],bandcol="gray90", main=i)
  abline(h=cim.perm[[i]],lty=2)
}

dev.off()
# more QTL found for cim method

save(cim.qtl, file = "~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
save(cim.perm, file = "~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata") 
```

### need a script to tell me which LG has significant QTL for different traits 
```{r}
load("~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")
load("~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.qtl.result <- 
lapply(names(cim.qtl), function(trait) {
  as.numeric(unique(cim.qtl[[trait]][(cim.qtl[[trait]]$lod > cim.perm[[trait]]),]$chr))
})

im.qtl.result <- 
lapply(names(scanone.imp), function(trait) {
  as.numeric(unique(scanone.imp[[trait]][(scanone.imp[[trait]]$lod > scanone.perm.imp[[trait]]),]$chr))
})

names(cim.qtl.result) <- names(cim.qtl)
names(im.qtl.result) <- names(scanone.imp) 
unlist(cim.qtl.result)
unlist(im.qtl.result)  
``` 

### get genes under QTL for different traits, use cim result, if there is no cim result, using scanone result 
```{r} 
load("~/F2/output/QTL_analysis/QTL_result_all.Rdata")

scanone.perm.imp.all %>% length()
scanone.imp.all %>% length() 
cim.perm.all %>% length()
cim.qtl.all %>% length()

### scanone 
threshold.95 <- tibble(perm.threshold = bind_rows(scanone.perm.imp.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(scanone.perm.imp.all)))
threshold.95

scanone.qtl.2 <-  
bind_cols(scanone.imp.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))
rownames(scanone.qtl.2) <- rownames(scanone.imp.all$Crude_oil_contents)
colnames(scanone.qtl.2)[3:ncol(scanone.qtl.2)] <- names(scanone.imp.all)

scanone.gather <- scanone.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

scanone.gather %>% head() 

# look for overlap, for each trait, find QTL border and look for genes under QTL peaks 
sig.chrs <- scanone.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n())
sig.chrs 

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(scanone.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  
 

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list 
bayesint.list %>% length() # 33

bayesint.result.scanone <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD)) %>% 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.
  mutate(start=ifelse(start==end,max(0,start-20000),start), end=ifelse(start==end,end+20000,end))

bayesint.result.scanone %>% dim() # 33 6 

### cim
threshold.95 <- tibble(perm.threshold = bind_rows(cim.perm.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(cim.perm.all)))
threshold.95

cim.qtl.2 <-  
bind_cols(cim.qtl.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))
rownames(cim.qtl.2) <- rownames(cim.qtl.all$Crude_oil_contents)
colnames(cim.qtl.2)[3:ncol(cim.qtl.2)] <- names(cim.qtl.all)

cim.gather <- cim.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

cim.gather %>% head() 

# look for overlap, for each trait, find QTL border and look for genes under QTL peaks 
sig.chrs <- cim.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n()) 
sig.chrs 

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(cim.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list 
bayesint.list %>% length() # 26

# save bayesint result for later 
bayesint.list.cim <- bayesint.list
bayesint.list.scanone <- bayesint.list 
save(bayesint.list.scanone, bayesint.list.cim, file = "~/F2/output/QTL_analysis/bayesint.list.scanone.cim.Rdata")

bayesint.result.cim <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD)) %>% 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.
  mutate(start=ifelse(start==end,max(0,start-20000),start), end=ifelse(start==end,end+20000,end))

bayesint.result.cim %>% dim() # 26 6  

bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))

bayesint.result <- 
bayesint.result.cim %>% 
  full_join(bayesint.result.scanone, by = c("trait", "chr")) 

bayesint.result %>% dim()
colnames(bayesint.result)

for (i in 1:nrow(bayesint.result)){
  if(is.na(bayesint.result[i, "start.x"])){
    bayesint.result[i, c(3:7)] <- bayesint.result[i, c(8:12)]
  }
}

bayesint.result <- bayesint.result[,1:7] 
colnames(bayesint.result) <- gsub("\\.x$", "", colnames(bayesint.result)) 

bayesint.result %>% dim() # 35 7

# annotate QTL  
load("~/Reference/B.napus/BnapusAnnotation.Rdata") 

traitQTL.annotated <- lapply(1:nrow(bayesint.result),function(row) { # for each trait/module 
  qtl <- bayesint.result[row,]  
  results <- subset(BnapusAnnotation, chrom==qtl$chr &
                    start >= qtl$start & # genes which fall into the QTL interval 
                    end <= qtl$end)
} 
)  
names(traitQTL.annotated) <- bayesint.result$trait 

traitQTL.annotated <- bind_rows(traitQTL.annotated,.id="trait") %>% # combine list into data.frame 
  mutate(chrom=as.character(chrom)) %>%
  left_join(bayesint.result,by=c("trait","chrom"="chr")) #get eQTL LOD

traitQTL.annotated <- 
traitQTL.annotated %>% 
  mutate(start = start.y, end = end.y) %>% 
  dplyr::select(-start.x, -end.x, -start.y, -end.y, -min_eQTL_LOD, -max_eQTL_LOD) 

traitQTL.annotated %>% dim() # 18647     9 

## get GO term for each gene
load("~/Reference/B.napus/napus_GO_combined.Rdata") # there is one colomn hiding... 

colnames(traitQTL.annotated)[3] <- "gene_ID"

traitQTL.annotated <- 
traitQTL.annotated %>% 
  left_join(napus_GO_combined) 

traitQTL.annotated %>% dim() #  18647    11 
save(traitQTL.annotated, file =  "~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata") 
```

# discrepency between previous result & current QTL result, FLC gene not located in the interval for days_to_flower anymore 
```{r}
load("~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata")

### current one 
traitQTL.annotated %>% 
  filter(trait == "days_to_flower") %>% 
  dplyr::select(start, end, chrom) %>% 
  unique() 
#        start      end chrom
# 1   15367151 15942430   A10
# 130 25340726 32476288   C06

traitQTL.annotated %>% 
  filter(trait == "days_to_bolt") %>% 
  dplyr::select(start, end, chrom)%>% 
  unique()  

#        start      end chrom
# 1   14613931 15142872   A10
# 134 22643132 31785732   C06

traitQTL.annotated[which(traitQTL.annotated$AGI == "AT5G10140" ),]

gff.mRNA[gff.mRNA$gene_ID == "BnaA10g22080D",] 
#   CHROM    start      end       gene_ID
#   chrA10 14998617 15003197 BnaA10g22080D

######## previous one 
load("~/F2/output/QTL_analysis/traitQTL.annotated.Rdata") 
traitQTL.annotated %>% 
  filter(trait == "days_to_flower") %>% 
  dplyr::select(start, end, chrom) %>% 
  unique() 

#        start      end chrom
#  14772310 15942430   A10
#  25340726 32476288   C06
```


### check important genes
```{r}
load("~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata")

traitQTL.annotated %>% dim() #  18647    11 
traitQTL.annotated %>% 
  filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT5G10140") # cool, FLC gene is on A10  

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT5G10140") # cool, FLC gene is on A10   

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT4G00650") # cool, FLC gene is on A10   

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT4G16280") # cool, FLC gene is on A10   

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT4G16845") # cool, FLC gene is on A10   

traitQTL.annotated %>% 
  filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(chrom == "C06") %>% 
  View() # cool, FLC gene is on A10   
 
# besides FLC, don't see other obvious flowering related genes here 
```  

### plot for paper 
```{r}
load("~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")
load("~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.perm.all <- cim.perm
cim.qtl.all <- cim.qtl
scanone.perm.imp.all <- scanone.perm.imp
scanone.imp.all <- scanone.imp

load("~/F2/output/growth_model/scanone_growth_model_trait_flipped.Rdata")
load("~/F2/output/growth_model/cim_growth_model_trait_flipped.Rdata") 

cim.perm.all <- c(cim.perm.all, cim.perm)[c(1:15, 17, 21:55)] 
cim.qtl.all <- c(cim.qtl.all, cim_growth_model_trait.F2)[c(1:15, 17, 21:55)]
scanone.perm.imp.all <- c(scanone.perm.imp.all[1:43], as.list(lod.thrs[5,]))[c(1:15, 17, 21:55)] 
scanone.imp.all <- c(scanone.imp.all, scanone_growth_model_trait.F2)[c(1:15, 17, 21:55)] 

cim.qtl.all[["vaccenic_acid"]] <- cim.qtl.all$vaccenic_acid[[1]]
cim.qtl.all[["vaccenic_acid"]] %>% class()
save(cim.perm.all, cim.qtl.all, scanone.perm.imp.all, scanone.imp.all, file = "~/F2/output/QTL_analysis/QTL_result_all.Rdata")

png("~/F2/output/QTL_analysis/figure/QTL_one_dim_flipped.png", width=30, height=30, units="in", res=300)
par(mfrow=c(11,5))

for (i in names(scanone.imp.all)){
  plot(scanone.imp.all[[i]],bandcol="gray90", main=i)
  abline(h=scanone.perm.imp.all[[i]],lty=2)
} 

dev.off()  

png("~/F2/output/QTL_analysis/figure/QTL_cim_flipped.png", width=30, height=30, units="in", res=300)
par(mfrow=c(11,5))

for (i in names(cim.qtl.all)){
  plot(cim.qtl.all[[i]],bandcol="gray90", main=i)
  abline(h=cim.perm.all[[i]],lty=2)
}

dev.off()  

cim.qtl.all[["vaccenic_acid"]] 
cim.perm.all[["vaccenic_acid"]] 

oil_ID <- c("Palmitic_acid", "Stearic_acid", "Oleic_acid", "vaccenic_acid", "Linoleic_acid", "Arachidic_acid", "Linolenic_acid", "Erucic_acid", "cis_11_Eicosenoic_acid", "Behenic_acid")

oil.plot <- list()
for (i in oil_ID){
  oil.plot[[i]] <- qtl_plot(input = rbind(data.frame(cim.qtl.all[[i]], method = "cim"), 
                       data.frame(scanone.imp.all[[i]], method = "scanone")),
         chrs = c("A08", "C03"), 
         lod = data_frame(group = c("cim_threshold", "scanone_threshold"),
                          lod = c(cim.perm.all[[i]],
                                  scanone.perm.imp.all[[i]])), 
         rug = TRUE, 
         labels = NA, 
         title = i) 
}

library(cowplot)
get_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}
legend <- get_legend(oil.plot[[1]]$plot)

oil.plot.2 <-plot_grid(
  oil.plot[[1]]$plot+theme(legend.position="none"),
  oil.plot[[2]]$plot+theme(legend.position="none"), 
  oil.plot[[3]]$plot+theme(legend.position="none"),
  oil.plot[[4]]$plot+theme(legend.position="none"),
  oil.plot[[5]]$plot+theme(legend.position="none"),
  oil.plot[[6]]$plot+theme(legend.position="none"),
  oil.plot[[7]]$plot+theme(legend.position="none"),
  oil.plot[[8]]$plot+theme(legend.position="none"),
  oil.plot[[9]]$plot+theme(legend.position="none"),
  oil.plot[[10]]$plot+theme(legend.position="none"),
  ncol=2, nrow = 5,labels=c("","","",""))  

oil.plot.3 <- plot_grid(oil.plot.2, legend, rel_heights = c(45, 1), ncol = 1, nrow = 2)
oil.plot.3 

ggsave(oil.plot.3, filename = "~/F2/output/QTL_analysis/figure/oil.plot.3.png", width = 12, height = 12)

growth_ID <- c("days_to_bolt", "days_to_flower", "leaf_number_2015_12_28", "leaf_number_2016_03_21", "lobe_number_2016_01_21", "root_weight_2016_05_13", "height_Hmax", "leaf_number_I", "lobe_number_I", "plant_height_2016_05_13") 
               
growth.plot <- list() 
for (i in growth_ID){
  growth.plot[[i]] <- qtl_plot(input = rbind(data.frame(cim.qtl.all[[i]], method = "cim"), 
                       data.frame(scanone.imp.all[[i]], method = "scanone")),
         chrs = c("A10", "C06"), 
         lod = data_frame(group = c("cim_threshold", "scanone_threshold"),
                          lod = c(cim.perm.all[[i]],
                                  scanone.perm.imp.all[[i]])), 
         rug = TRUE, 
         labels = NA, 
         title = i) 
}   

growth.plot.2 <-plot_grid( 
  growth.plot[[1]]$plot+theme(legend.position="none"),
  growth.plot[[2]]$plot+theme(legend.position="none"), 
  growth.plot[[3]]$plot+theme(legend.position="none"),
  growth.plot[[4]]$plot+theme(legend.position="none"),
  growth.plot[[5]]$plot+theme(legend.position="none"), 
  growth.plot[[6]]$plot+theme(legend.position="none"),
  growth.plot[[7]]$plot+theme(legend.position="none"),
  growth.plot[[8]]$plot+theme(legend.position="none"),
  growth.plot[[9]]$plot+theme(legend.position="none"),
  growth.plot[[10]]$plot+theme(legend.position="none"),
  # legend, 
  ncol=2, nrow = 5,labels=c("","","",""))  

growth.plot.3 <- plot_grid(growth.plot.2, legend, rel_heights = c(45, 1), ncol = 1, nrow = 2)
growth.plot.3 

ggsave(growth.plot.3, filename = "~/F2/output/QTL_analysis/figure/growth.plot.3.png", width = 12, height = 12)

#### make scanone and CIM plot for each trait 
load("~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")
load("~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.perm.all <- cim.perm
cim.qtl.all <- cim.qtl
scanone.perm.imp.all <- scanone.perm.imp
scanone.imp.all <- scanone.imp

load("~/F2/output/growth_model/scanone_growth_model_trait_flipped.Rdata")
load("~/F2/output/growth_model/cim_growth_model_trait_flipped.Rdata") 

cim.perm.all <- c(cim.perm.all, cim.perm) 
cim.qtl.all <- c(cim.qtl.all, cim_growth_model_trait.F2)
scanone.perm.imp.all <- c(scanone.perm.imp.all[1:43], as.list(lod.thrs[5,]))
scanone.imp.all <- c(scanone.imp.all, scanone_growth_model_trait.F2)

save(cim.perm.all, cim.qtl.all, scanone.perm.imp.all, scanone.imp.all, file = "~/F2/output/QTL_analysis/QTL_result_all_all.Rdata") 

qtl_all <-   
  lapply(names(cim.qtl.all), function(trait) {
    qtl_plot(input = rbind(data.frame(cim.qtl.all[[trait]], method = "cim"), 
                       data.frame(scanone.imp.all[[trait]], method = "scanone")),
         lod = data_frame(group = c("cim_threshold", "scanone_threshold"),
                          lod = c(cim.perm.all[[trait]],
                                  scanone.perm.imp.all[[trait]])), 
         rug = TRUE, 
         title = trait
         )  
  })

plots <- lapply(1:length(qtl_all), function(trait) qtl_all[[trait]]$plot)

paths <- stringr::str_c(names(cim.qtl.all), ".pdf") 
paths 
pwalk(list(paths, plots), ggsave, path = "~/F2/output/QTL_analysis/figure/", width = 15, height = 7) # save on whitney   
``` 

### redo QTL analysis for several traits which don't follow normal distribution 
```{r}
### load data and run scanone & cim
LG.f2.after.crossover <- read.cross("csvsr", genfile = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/LG.f2.madmapper.final_gen_revised_flipped.csv",
                     phefile = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/F2.pheno.csv",
                     genotypes = c("AA", "AB", "BB")) # the only problem is that 44 phenotypes were read instead of 43, need to figure out why later

plot.map(LG.f2.after.crossover)
summaryMap(LG.f2.after.crossover) # 2884

LG.f2.after.crossover <- sim.geno(LG.f2.after.crossover,step=1,n.draws=32) # imputation
LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover,step=1) # calculate the probability of the true underlying genotypes given the observed multipoint marker data --> for each imputed data, give a probability?

LG.f2.after.crossover$pheno %>% colnames() # Caprylic_acid, Myristic_acid, Heptadecanoic_acid, should try "2 part" model in scanone(), Survival_rate use log transformed data to get normality 

scanone_Caprylic <- 
scanone(LG.f2.after.crossover, pheno.col = "Caprylic_acid", method = "em", model = "2part", upper = F)

# permutation 
perm_Caprylic <- 
scanone(LG.f2.after.crossover, pheno.col = "Caprylic_acid", method = "em", model = "2part", upper = F, n.perm = 1000)

summary(perm_Caprylic)[1] # 5.632463 
summary(perm_Caprylic, alpha = 0.05)

plot(scanone_Caprylic,bandcol="gray90", main="Caprylic_acid")
abline(h=summary(perm_Caprylic)[1],lty=2) #add permuation threshold

### Myristic acid 
scanone_Myristic <-
scanone(LG.f2.after.crossover, pheno.col = "Myristic_acid", method = "em", model = "2part", upper = F)

perm_Myristic <-
scanone(LG.f2.after.crossover, pheno.col = "Myristic_acid", method = "em", model = "2part", upper = F, n.perm = 1000) # upper=F to indicate that in the 2part model, phenotype is the smallest observed phenotype 
summary(perm_Myristic)[1] 
summary(perm_Myristic, alpha = 0.05)

plot(scanone_Myristic,bandcol="gray90", main="Myristic_acid")
abline(h=summary(perm_Myristic)[1],lty=2) #add permuation threshold # same result as identified from normal model 

### Heptadecanoic_acid don't worry, to few data points 

### survival rate, transformaion won't work because a lot of 0, is there any other model for survival rate? 
hist(sqrt(LG.f2.after.crossover$pheno$Survival_rate)) 
ggplot(LG.f2.after.crossover$pheno, aes(x = Survival_rate)) + geom_histogram(bins=15) + scale_x_log10() 
min(LG.f2.after.crossover$pheno$Survival_rate, na.rm = T)  

scanone_Survival_rate <-
scanone(LG.f2.after.crossover, pheno.col = "Survival_rate", model = "np")

perm_Survival_rate <-
scanone(LG.f2.after.crossover, pheno.col = "Survival_rate", model = "np", n.perm = 1000) # upper=F to indicate that in the 2part model, phenotype is the smallest observed phenotype 
summary(Survival_rate)[1] 
summary(perm_Survival_rate, alpha = 0.05) 

plot(scanone_Survival_rate,bandcol="gray90", main="Myristic_acid")
abline(h=summary(perm_Survival_rate)[1],lty=2) #add permuation threshold # same result as identified from normal model 

save(scanone_Caprylic, scanone_Myristic, scanone_Survival_rate, perm_Caprylic, perm_Myristic, file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/output/QTL_nonnormality.Rdata") 
```

### table to summarize QTL mapping result, make R square, additive effect... 
```{r}
load("~/F2/output/QTL_analysis/bayesint.list.scanone.cim.Rdata")
length(bayesint.list.scanone) # 33
length(bayesint.list.cim) # 26 

bayesint.result.scanone <- as.tibble(bind_rows(bayesint.list.scanone,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(pos, na.rm = T),end=max(pos, na.rm = T),pos = median(pos, na.rm = T), LOD=max(LOD))  

bayesint.result.scanone %>% dim() # 33 6 

bayesint.result.tmp <- as.tibble(bind_rows(bayesint.list.scanone,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) 

bayesint.result.tmp$index <- paste(bayesint.result.tmp$trait, bayesint.result.tmp$chr, bayesint.result.tmp$LOD)
bayesint.result.scanone$index <- paste(bayesint.result.scanone$trait, bayesint.result.scanone$chr, bayesint.result.scanone$LOD)

test <- 
bayesint.result.tmp %>% 
  anti_join(bayesint.result.scanone) %>% 
  dplyr::select(trait, chr, markername) %>% 
  mutate(index = paste(trait, chr, sep = "_")) 

tmp <- c()
tmp  

for (i in seq_along(1:(nrow(test)/2))){
  tmp[i] <- paste(test$markername[i*2-1], test$markername[i*2-0], sep = "-") 
}

bayesint.result.scanone$index <- tmp

bayesint.result.scanone <- 
bayesint.result.scanone %>%
  mutate(start = round(start, 2), end = round(end, 2), pos = round(pos, 2), LOD = round(LOD, 2)) %>%
  unite(confidence_interval, start, end, sep = "-") %>% 
  mutate(flanking_marker = index) %>% 
  dplyr::select(-index)  

bayesint.result.scanone %>% dim() # 33 6 

### cim result 
bayesint.list.cim %>% length() # 26

bayesint.result <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(pos, na.rm = T),end=max(pos, na.rm = T),pos = median(pos, na.rm = T), LOD=max(LOD)) 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.

bayesint.result %>% dim() # 26 6 
bayesint.result 

bayesint.result.tmp <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) 

bayesint.result.tmp$index <- paste(bayesint.result.tmp$trait, bayesint.result.tmp$chr, bayesint.result.tmp$LOD)
bayesint.result$index <- paste(bayesint.result$trait, bayesint.result$chr, bayesint.result$LOD)

test <- 
bayesint.result.tmp %>% 
  anti_join(bayesint.result) %>% 
  dplyr::select(trait, chr, markername) %>% 
  mutate(index = paste(trait, chr, sep = "_")) 

tmp <- c()
tmp  

for (i in seq_along(1:(nrow(test)/2))){
  tmp[i] <- paste(test$markername[i*2-1], test$markername[i*2-0], sep = "-") 
}

bayesint.result$index <- tmp

bayesint.result.cim <- 
bayesint.result %>% 
  mutate(start = round(start, 2), end = round(end, 2), pos = round(pos, 2), LOD = round(LOD, 2)) %>%
  unite(confidence_interval, start, end, sep = "-") %>% 
  mutate(flanking_marker = index) %>% 
  dplyr::select(-index)  

bayesint.result.cim %>% dim() # 26 6  

### combine cim & scanone result 
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))
bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))

bayesint.result.paper <- 
bayesint.result.cim %>% 
  full_join(bayesint.result.scanone, by = c("trait", "chr")) 

bayesint.result.paper %>% dim() # 32 12
colnames(bayesint.result.paper)

for (i in 1:nrow(bayesint.result.paper)){
  if(is.na(bayesint.result.paper[i, "pos.x"])){
    bayesint.result.paper[i, c(3:7)] <- bayesint.result.paper[i, c(8:12)]
  }
}

bayesint.result.paper <- bayesint.result.paper[,1:7] 
colnames(bayesint.result.paper) <- gsub("\\.x$", "", colnames(bayesint.result.paper)) 

bayesint.result.paper %>% dim() # 35 7 
bayesint.result.paper %>% View()

save(bayesint.result.paper, file = "~/F2/output/QTL_analysis/bayesint.result.paper.Rdata") 
write.csv(bayesint.result.paper, file = "~/F2/output/QTL_analysis/bayesint.result.paper.csv") 

### re-edit the position according to scantwo result 

### 1) days_to_flower 
# 		fitqtl summary
# 
# Method: multiple imputation 
# Model:  normal phenotype
# Number of observations : 165 
# 
# Full model result
# ----------------------------------  
# Model formula: y ~ Q1 + Q2 
# 
#        df       SS        MS      LOD     %var Pvalue(Chi2)    Pvalue(F)
# Model   4 10800.02 2700.0041 12.45336 29.36008 1.044798e-11 2.055756e-11
# Error 160 25984.69  162.4043                                            
# Total 164 36784.70                                                      
# 
# 
# Drop one QTL at a time ANOVA table: 
# ----------------------------------  
#           df Type III SS   LOD  %var F value Pvalue(Chi2) Pvalue(F)    
# A10@183.9  2        6080 7.533 16.53   18.72            0  4.96e-08 ***
# C06@67.3   2        4264 5.444 11.59   13.13            0  5.26e-06 *** ####### need to change this pos
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# 
# Estimated effects:
# -----------------
#                  est        SE       t
# Intercept  151.55170   1.01004 150.046 
# A10@183.9a  -7.35767   1.33487  -5.512
# A10@183.9d   4.71660   2.03236   2.321
# C06@67.3a   -7.63332   1.49116  -5.119
# C06@67.3d   -0.09159   2.02693  -0.045

### linolenic acid 
# Full model result
# ----------------------------------  
# Model formula: y ~ Q1 + Q2 + Q1:Q2 
# 
#        df        SS       MS      LOD     %var Pvalue(Chi2) Pvalue(F)
# Model   8 1335.8103 166.9763 66.82275 84.33586            0         0
# Error 157  248.1071   1.5803                                         
# Total 165 1583.9174                                                  
# 
# 
# Drop one QTL at a time ANOVA table: 
# ----------------------------------  
#                    df Type III SS   LOD  %var F value Pvalue(Chi2) Pvalue(F)    
# A08@39.0            6      1183.1 63.17 74.70   124.8            0    <2e-16 ***
# C03@181.0           6      1124.7 61.67 71.01   118.6            0    <2e-16 ***
# A08@39.0:C03@181.0  4       982.3 57.72 62.02   155.4            0    <2e-16 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# 
# Estimated effects:
# -----------------
#                          est      SE       t
# Intercept            10.8127  0.1293  83.606
# A08@39.0a            -0.3259  0.1892  -1.722
# A08@39.0d             1.7490  0.2591   6.752
# C03@181.0a           -0.8086  0.1862  -4.343
# C03@181.0d            0.9781  0.2588   3.779 
# A08@39.0a:C03@181.0a -4.3295  0.2648 -16.349
# A08@39.0d:C03@181.0a  1.3157  0.3739   3.519
# A08@39.0a:C03@181.0d  1.2020  0.3776   3.183
# A08@39.0d:C03@181.0d -0.7604  0.5193  -1.464

### days_to_bolt ### the additional marker is maginal, can add or not, so no need to care about it too much 

# Full model result
# ----------------------------------  
# Model formula: y ~ Q1 + Q2 + Q3 
# 
#        df       SS        MS      LOD    %var Pvalue(Chi2)    Pvalue(F)
# Model   6 11634.05 1939.0081 15.47209 35.0679 2.263745e-13 6.379341e-13
# Error 158 21541.73  136.3401                                           
# Total 164 33175.78                                                     
# 
# 
# Drop one QTL at a time ANOVA table: 
# ----------------------------------  
#           df Type III SS   LOD  %var F value Pvalue(Chi2) Pvalue(F)    
# A10@176.0  2        4731 7.113 14.26  17.350            0  1.54e-07 ***
# C06@85.7   2        3833 5.868 11.55  14.057            0  2.41e-06 ***
# A05@114.0  2        2697 4.227  8.13   9.891            0  8.97e-05 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# 
# Estimated effects:
# -----------------
#                 est       SE       t
# Intercept  119.4954   0.9383 127.351
# A10@176.0a  -7.0704   1.2035  -5.875
# A10@176.0d   1.0081   1.8948   0.532
# C06@85.7a   -7.2351   1.4103  -5.130
# C06@85.7d    2.4429   1.8949   1.289
# A05@114.0a   5.7853   1.3349   4.334
# A05@114.0d  -0.6941   1.9010  -0.365

### linolenic acid, need to be more careful to analyze 

### combine with allele effect information 
bayesint.result.paper.2 <- read.csv("~/F2/output/QTL_analysis/bayesint.result.paper.2.csv")
bayesint.result.paper.2   

write.csv(bayesint.result.paper.2, file = "~/F2/output/QTL_analysis/bayesint.result.paper.3.csv")  
```





















