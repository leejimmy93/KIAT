---
title: "QTL_analysis_flipped"
output: html_document
---

### purpose of this script is to finish QTL analysis with several LG flipped 

```{r}
### load lib
library(tidyverse)
library(qtl) 
library(snowfall)
library(ggrepel) 
library(Biostrings)   
source("~/KIAT/function_BnRNAseq.R")   

### load data and run scanone & cim
LG.f2.after.crossover <- read.cross("csvsr", genfile = "~/F2/data/QTL_analysis/LG.f2.madmapper.final_gen_revised_flipped.csv",
                     phefile = "~/F2/data/QTL_analysis/F2.pheno.csv", 
                     genotypes = c("AA", "AB", "BB")) # the only problem is that 44 phenotypes were read instead of 43, need to figure out why later 

plot.map(LG.f2.after.crossover) 
map.summary <- summaryMap(LG.f2.after.crossover) # 2884
write.csv(map.summary, file = "~/F2/output/QTL_analysis/map.summary.csv")   

LG.f2.after.crossover <- sim.geno(LG.f2.after.crossover,step=1,n.draws=32) # imputation
LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover,step=1) # calculate the probability of the true underlying genotypes given the observed multipoint marker data --> for each imputed data, give a probability?

sfInit(parallel = TRUE, cpus = 4)
sfExport("LG.f2.after.crossover") 
sfLibrary(qtl)

system.time(
scanone.perm.imp <-
  sfLapply(seq_along(LG.f2.after.crossover$pheno), function(trait){
    print(trait) # print doesn't work in here
    tmp <-scanone(LG.f2.after.crossover,pheno.col = trait, method="imp",n.perm=1000, n.cluster = 16)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes 40 mins to finish
)
sfStop()

names(scanone.perm.imp) <- colnames(LG.f2.after.crossover$pheno)
save(scanone.perm.imp, file = "~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")

# Erucic acid 
scanone.imp.Erucic <- scanone(LG.f2.after.crossover,pheno.col=15,method="imp") #
plot(scanone.imp.Erucic,bandcol="gray90", main="Erucic_acid")
abline(h=scanone.perm.imp[["Erucic_acid"]],lty=2) #add permuation threshold

# Oleic acid
scanone.imp.Oleic <- scanone(LG.f2.after.crossover,pheno.col=8,method="imp") #
plot(scanone.imp.Oleic,bandcol="gray90", main="Oleic_acid")
abline(h=scanone.perm.imp[["Oleic_acid"]],lty=2) #add permuation threshold

system.time(
scanone.imp <-
lapply(seq_along(LG.f2.after.crossover$pheno[1:43]), function(trait) {
  print(trait)
  scanone(LG.f2.after.crossover,pheno.col=trait,method="imp")
})
)
names(scanone.imp) <- colnames(LG.f2.after.crossover$pheno)[1:43]

png("~/F2/output/QTL_analysis/figure/QTL_one_dim_flipped.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(scanone.imp)){
  plot(scanone.imp[[i]],bandcol="gray90", main=i)
  abline(h=scanone.perm.imp[[i]],lty=2)
}

dev.off()

save(scanone.imp, file = "~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.qtl <-
lapply(seq_along(LG.f2.after.crossover$pheno)[1:43], function(trait) {
  print(trait)
  cim(LG.f2.after.crossover, n.marcovar=5, pheno.col=trait,method="em")
})

cim.qtl[["vaccenic_acid"]] 

# here we use the interval mapping method "em" as this is how cim was originaly implmented.the n.marcovar= argument defines the maximum number of marker covariates to use.
names(cim.qtl) <- colnames(LG.f2.after.crossover$pheno)[1:43]

sfInit(parallel = TRUE, cpus = 4)
sfExport("LG.f2.after.crossover")
sfLibrary(qtl)

cim.perm <-
  sfLapply(seq_along(LG.f2.after.crossover$pheno)[1:43], function(trait){
    message(trait) # message doesn't work in here either
    tmp <- cim(LG.f2.after.crossover,
               pheno.col = trait,
               n.marcovar=5,
               method="em",
               n.perm=1000)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes almost 4 hours to finish

sfStop() 

names(cim.perm) <- colnames(LG.f2.after.crossover$pheno)[1:43]

# plot out result and save plot
png("~/F2/output/QTL_analysis/figure/QTL_cim_1_flipped.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(cim.qtl)){
  plot(cim.qtl[[i]],bandcol="gray90", main=i)
  abline(h=cim.perm[[i]],lty=2)
}

dev.off()
# more QTL found for cim method

save(cim.qtl, file = "~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
save(cim.perm, file = "~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata") 
```

### need a script to tell me which LG has significant QTL for different traits 
```{r}
load("~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")
load("~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.qtl.result <- 
lapply(names(cim.qtl), function(trait) {
  as.numeric(unique(cim.qtl[[trait]][(cim.qtl[[trait]]$lod > cim.perm[[trait]]),]$chr))
})

im.qtl.result <- 
lapply(names(scanone.imp), function(trait) {
  as.numeric(unique(scanone.imp[[trait]][(scanone.imp[[trait]]$lod > scanone.perm.imp[[trait]]),]$chr))
})

names(cim.qtl.result) <- names(cim.qtl)
names(im.qtl.result) <- names(scanone.imp) 
unlist(cim.qtl.result)
unlist(im.qtl.result)  
``` 

### get genes under QTL for different traits, use cim result, if there is no cim result, using scanone result 
```{r} 
load("~/F2/output/QTL_analysis/QTL_result_all.Rdata")

scanone.perm.imp.all %>% length() # 51 
scanone.imp.all %>% length() 
cim.perm.all %>% length()
cim.qtl.all %>% length()

### scanone 
threshold.95 <- tibble(perm.threshold = bind_rows(scanone.perm.imp.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(scanone.perm.imp.all)))
threshold.95

scanone.qtl.2 <-  
bind_cols(scanone.imp.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))
rownames(scanone.qtl.2) <- rownames(scanone.imp.all$Crude_oil_contents)
colnames(scanone.qtl.2)[3:ncol(scanone.qtl.2)] <- names(scanone.imp.all)

scanone.gather <- scanone.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

scanone.gather %>% head() 

# look for overlap, for each trait, find QTL border and look for genes under QTL peaks 
sig.chrs <- scanone.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n())
sig.chrs 

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(scanone.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  
 

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list 
bayesint.list %>% length() # 33

bayesint.result.scanone <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD), genetic_start=min(pos, na.rm = T), genetic_end=max(pos, na.rm = T)) %>% 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.
  mutate(start=ifelse(start==end,max(0,start-20000),start), end=ifelse(start==end,end+20000,end))

bayesint.result.scanone %>% dim() # 33 8 

### cim
threshold.95 <- tibble(perm.threshold = bind_rows(cim.perm.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(cim.perm.all)))
threshold.95

cim.qtl.2 <-  
bind_cols(cim.qtl.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))
rownames(cim.qtl.2) <- rownames(cim.qtl.all$Crude_oil_contents)
colnames(cim.qtl.2)[3:ncol(cim.qtl.2)] <- names(cim.qtl.all)

cim.gather <- cim.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

cim.gather %>% head() 

# look for overlap, for each trait, find QTL border and look for genes under QTL peaks 
sig.chrs <- cim.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n()) 
sig.chrs 

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(cim.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list 
bayesint.list %>% length() # 26 

# save bayesint result for later 
bayesint.list.cim <- bayesint.list
bayesint.list.scanone <- bayesint.list 
save(bayesint.list.scanone, bayesint.list.cim, file = "~/F2/output/QTL_analysis/bayesint.list.scanone.cim.Rdata")

bayesint.result.cim <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD), genetic_start=min(pos, na.rm = T), genetic_end=max(pos, na.rm = T)) %>% 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.
  mutate(start=ifelse(start==end,max(0,start-20000),start), end=ifelse(start==end,end+20000,end))

bayesint.result.cim %>% dim() # 26 8

bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))

bayesint.result <- 
bayesint.result.cim %>% 
  full_join(bayesint.result.scanone, by = c("trait", "chr")) 

bayesint.result %>% dim() # 35 16 
colnames(bayesint.result)

for (i in 1:nrow(bayesint.result)){
  if(is.na(bayesint.result[i, "start.x"])){
    bayesint.result[i, c(3:9)] <- bayesint.result[i, c(10:16)]
  }
}

bayesint.result <- bayesint.result[,1:9] 
colnames(bayesint.result) <- gsub("\\.x$", "", colnames(bayesint.result)) 

bayesint.result %>% dim() # 35 9 

# annotate QTL   
load("~/Reference/B.napus/BnapusAnnotation.Rdata") 

## where are the genes fkf for flowering time (Long et al. 2007) 
BnapusAnnotation %>% colnames()
BnapusAnnotation %>% 
  filter(AGI == "AT1G68050") 
###

traitQTL.annotated <- lapply(1:nrow(bayesint.result),function(row) { # for each trait/module 
  qtl <- bayesint.result[row,]  
  results <- subset(BnapusAnnotation, chrom==qtl$chr &
                    start >= qtl$start & # genes which fall into the QTL interval 
                    end <= qtl$end)
} 
)  
names(traitQTL.annotated) <- bayesint.result$trait 

traitQTL.annotated <- bind_rows(traitQTL.annotated,.id="trait") %>% # combine list into data.frame 
  mutate(chrom=as.character(chrom)) %>%
  left_join(bayesint.result,by=c("trait","chrom"="chr")) #get eQTL LOD

traitQTL.annotated <- 
traitQTL.annotated %>% 
  mutate(start = start.y, end = end.y) %>% 
  dplyr::select(-start.x, -end.x, -start.y, -end.y, -min_eQTL_LOD, -max_eQTL_LOD) 

traitQTL.annotated %>% dim() # 18647     11

## get GO term for each gene
load("~/Reference/B.napus/napus_GO_combined.Rdata") # there is one colomn hiding... 

colnames(traitQTL.annotated)[3] <- "gene_ID"

traitQTL.annotated <- 
traitQTL.annotated %>% 
  left_join(napus_GO_combined) 

traitQTL.annotated %>% dim() #  18647    13 
save(traitQTL.annotated, file =  "~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata") 
write.csv(traitQTL.annotated, file = "~/F2/for_paper/traitQTL.annotated.csv") 
```

# discrepency between previous result & current QTL result, FLC gene not located in the interval for days_to_flower anymore 
```{r}
load("~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata")

### current one 
traitQTL.annotated %>% 
  filter(trait == "days_to_flower") %>% 
  dplyr::select(start, end, chrom) %>% 
  unique() 
#        start      end chrom
# 1   15367151 15942430   A10
# 130 25340726 32476288   C06

traitQTL.annotated %>% 
  filter(trait == "days_to_bolt") %>% 
  dplyr::select(start, end, chrom)%>% 
  unique()  

#        start      end chrom
# 1   14613931 15142872   A10
# 134 22643132 31785732   C06

traitQTL.annotated[which(traitQTL.annotated$AGI == "AT5G10140" ),]

gff.mRNA[gff.mRNA$gene_ID == "BnaA10g22080D",] 
#   CHROM    start      end       gene_ID
#   chrA10 14998617 15003197 BnaA10g22080D

gff.mRNA[gff.mRNA$gene_ID == "BnaA08g12780D",] # FAD
#   CHROM    start      end       gene_ID
#   chrA10 14998617 15003197 BnaA10g22080D

gff.mRNA[gff.mRNA$gene_ID == "BnaA08g12800D",] # FAD
#   CHROM    start      end       gene_ID
#   chrA10 14998617 15003197 BnaA10g22080D

gff.mRNA[gff.mRNA$gene_ID == "BnaC03g67820D",] # FAD
#   CHROM    start      end       gene_ID
#   chrA10 14998617 15003197 BnaA10g22080D 

######## previous one 
load("~/F2/output/QTL_analysis/traitQTL.annotated.Rdata") 
traitQTL.annotated %>% 
  filter(trait == "days_to_flower") %>% 
  dplyr::select(start, end, chrom) %>% 
  unique() 

#        start      end chrom
#  14772310 15942430   A10
#  25340726 32476288   C06 
```


### check important genes under QTL interval for different traits 
```{r}
load("~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata")

traitQTL.annotated %>% colnames()
traitQTL.annotated %>% 
  group_by(trait, chrom) %>% 
  dplyr::summarise(count = n()) %>% 
  dim()

traitQTL.annotated %>% dim() #  18647    11 
traitQTL.annotated %>% 
  filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT5G10140") # cool, FLC gene is on A10  

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT5G10140") 

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT4G00650") 

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT4G16280") 

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT4G16845") 

traitQTL.annotated %>% 
  filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(chrom == "C06") %>% 
  View() # cool, FLC gene is on A10   
 
# besides FLC, don't see other obvious flowering related genes here  

### check trait QTL result 
traitQTL.annotated %>% 
    filter(gene_ID == "BnaA08g11130D") %>% 
  View() # FAE1    

traitQTL.annotated %>% 
    filter(gene_ID == "BnaA08g11140D") %>%  
  View() # KCS1 

traitQTL.annotated %>% 
    filter(gene_ID == "BnaC03g65980D") %>% 
  View() # FAE1    

traitQTL.annotated %>% 
    filter(gene_ID == "BnaC03g66040D") %>% 
  View() # KCS1  

traitQTL.annotated %>% 
    filter(gene_ID == "BnaC03g67820D") %>% 
  View() # FAD6  

traitQTL.annotated %>% 
    filter(gene_ID == "BnaA08g12780D") %>% 
  View() # FAD  

traitQTL.annotated %>% 
    filter(gene_ID == "BnaA08g12800D") %>% 
  View() # FAD    

traitQTL.annotated %>% 
    filter(AGI == "AT1G68050") %>% 
  View() # FAD   

traitQTL.annotated %>% 
    filter(AGI == "AT4G30950") %>% 
  View() # sequalene synthase  

traitQTL.annotated %>% 
    # traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Palmitic_acid") %>% 
  View() # sequalene synthase 

# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Myristic_acid") %>% 
  View() # sequalene synthase 

# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Palmitoliec_aicd") %>% 
  View() # sequalene synthase  
 
# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Behenic_acid") %>% 
  View() # sequalene synthase  
    
# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Stearic_acid") %>% 
  View() # sequalene synthase 
    
# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Oleic_acid") %>% 
  View() # sequalene synthase 

# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Linoleic_acid") %>% 
  View() # sequalene synthase 

# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Linolenic_acid") %>% 
  View() # sequalene synthase 
            
# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Arachidic_acid") %>% 
  View() # sequalene synthase 

# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Erucic_acid") %>% 
  View() # sequalene synthase 
    
# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "vaccenic_acid") %>% 
  View() # sequalene synthase 
        
# traitQTL.annotated %>% 
    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Behenic_acid") %>% 
  View() # sequalene synthase 
    
traitQTL.annotated %>% 
#    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(trait == "Crude_oil_contents") %>% 
  View() # sequalene synthase 

traitQTL.annotated %>% 
#    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(chrom == "C06" & trait == "days_to_bolt") %>% 
  View() # sequalene synthase  

plant_width <- 
traitQTL.annotated %>% 
#    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(chrom == "C02") 

source("~/Desktop/Brassica_project/KIAT_RNA_seq/analysis/function_BnRNAseq.R")  
load("~/Desktop/plant_width.Rdata")
GOseq.Bn.ORA(plant_width$gene_ID) # no enriched GO term 

load("~/Desktop/cis_plant_width.Rdata")
GOseq.Bn.ORA(cis_plant_width$gene_ID) # no enriched GO term  
=======
save(plant_width, file = "~/F2/for_paper/plant_width.Rdata") 
>>>>>>> ebf1da51238d5779874fb4a82a8512eec9d24049  

traitQTL.annotated %>% 
#    traitQTL.annotated[grep("lipid|fatty", traitQTL.annotated$GO_des),] %>%
    filter(chrom == "C02" & AGI == "AT4G19700") %>% 
  View() # sequalene synthase  

traitQTL.annotated %>% colnames()  
traitQTL.annotated$trait %>% unique() 

#### other important flower genes under C06? 
### important flower related genes 
flowering_time_gene <- read.csv("~/F2/for_paper/flowering_time/flowering_time_genes.csv")
flowering_time_gene$Gene.number <- gsub("\\ ", "", flowering_time_gene$Gene.number)
flowering_time_gene$Gene.number <- gsub("\\\xca", "", flowering_time_gene$Gene.number) 

traitQTL.annotated[traitQTL.annotated$AGI %in% flowering_time_gene$Gene.number,] %>% 
  filter(chrom == "C06") %>%
  # dplyr::select(gene_ID, trait.y, AGI, At_symbol, GO_des) %>%
  View() 

flowering_time_gene %>% colnames()
flowering_time_gene %>% 
  filter(Gene.number == "AT1G69120")

flowering_time_gene %>% 
  filter(Gene.number == "AT1G69570")

flowering_time_gene %>% 
  filter(Gene.number == "AT1G65480")

BnapusAnnotation %>% 
  filter(AGI == "AT1G65480") 
```

### plot for paper 
```{r}
load("~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")
load("~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.perm.all <- cim.perm
cim.qtl.all <- cim.qtl
scanone.perm.imp.all <- scanone.perm.imp
scanone.imp.all <- scanone.imp

load("~/F2/output/growth_model/scanone_growth_model_trait_flipped.Rdata")
load("~/F2/output/growth_model/cim_growth_model_trait_flipped.Rdata") 

cim.perm.all <- c(cim.perm.all, cim.perm)[c(1:15, 17, 21:55)] 
cim.qtl.all <- c(cim.qtl.all, cim_growth_model_trait.F2)[c(1:15, 17, 21:55)]
scanone.perm.imp.all <- c(scanone.perm.imp.all[1:43], as.list(lod.thrs[5,]))[c(1:15, 17, 21:55)] 
scanone.imp.all <- c(scanone.imp.all, scanone_growth_model_trait.F2)[c(1:15, 17, 21:55)] 

cim.qtl.all[["vaccenic_acid"]] <- cim.qtl.all$vaccenic_acid[[1]]
cim.qtl.all[["vaccenic_acid"]] %>% class()
save(cim.perm.all, cim.qtl.all, scanone.perm.imp.all, scanone.imp.all, file = "~/F2/output/QTL_analysis/QTL_result_all.Rdata")

png("~/F2/output/QTL_analysis/figure/QTL_one_dim_flipped.png", width=30, height=30, units="in", res=300)
par(mfrow=c(11,5))

for (i in names(scanone.imp.all)){
  plot(scanone.imp.all[[i]],bandcol="gray90", main=i)
  abline(h=scanone.perm.imp.all[[i]],lty=2)
} 

dev.off()  

png("~/F2/output/QTL_analysis/figure/QTL_cim_flipped.png", width=30, height=30, units="in", res=300)
par(mfrow=c(11,5))

for (i in names(cim.qtl.all)){
  plot(cim.qtl.all[[i]],bandcol="gray90", main=i)
  abline(h=cim.perm.all[[i]],lty=2)
}

dev.off()  

cim.qtl.all[["vaccenic_acid"]] 
cim.perm.all[["vaccenic_acid"]] 

oil_ID <- c("Palmitic_acid", "Stearic_acid", "Oleic_acid", "vaccenic_acid", "Linoleic_acid", "Arachidic_acid", "Linolenic_acid", "Erucic_acid", "cis_11_Eicosenoic_acid", "Behenic_acid")

oil.plot <- list()
for (i in oil_ID){
  oil.plot[[i]] <- qtl_plot(input = rbind(data.frame(cim.qtl.all[[i]], method = "cim"), 
                       data.frame(scanone.imp.all[[i]], method = "scanone")),
         chrs = c("A08", "C03"), 
         lod = data_frame(group = c("cim_threshold", "scanone_threshold"),
                          lod = c(cim.perm.all[[i]],
                                  scanone.perm.imp.all[[i]])), 
         rug = TRUE, 
         labels = NA, 
         title = i) 
}

library(cowplot)
get_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}
legend <- get_legend(oil.plot[[1]]$plot)

oil.plot.2 <-plot_grid(
  oil.plot[[1]]$plot+theme(legend.position="none"),
  oil.plot[[2]]$plot+theme(legend.position="none"), 
  oil.plot[[3]]$plot+theme(legend.position="none"),
  oil.plot[[4]]$plot+theme(legend.position="none"),
  oil.plot[[5]]$plot+theme(legend.position="none"),
  oil.plot[[6]]$plot+theme(legend.position="none"),
  oil.plot[[7]]$plot+theme(legend.position="none"),
  oil.plot[[8]]$plot+theme(legend.position="none"),
  oil.plot[[9]]$plot+theme(legend.position="none"),
  oil.plot[[10]]$plot+theme(legend.position="none"),
  ncol=2, nrow = 5,labels=c("","","",""))  

oil.plot.3 <- plot_grid(oil.plot.2, legend, rel_heights = c(45, 1), ncol = 1, nrow = 2)
oil.plot.3 

ggsave(oil.plot.3, filename = "~/F2/output/QTL_analysis/figure/oil.plot.3.png", width = 12, height = 12)

growth_ID <- c("days_to_bolt", "days_to_flower", "leaf_number_2015_12_28", "leaf_number_2016_03_21", "lobe_number_2016_01_21", "root_weight_2016_05_13", "height_Hmax", "leaf_number_I", "lobe_number_I", "plant_height_2016_05_13") 
               
growth.plot <- list() 
for (i in growth_ID){
  growth.plot[[i]] <- qtl_plot(input = rbind(data.frame(cim.qtl.all[[i]], method = "cim"), 
                       data.frame(scanone.imp.all[[i]], method = "scanone")),
         chrs = c("A10", "C06"), 
         lod = data_frame(group = c("cim_threshold", "scanone_threshold"),
                          lod = c(cim.perm.all[[i]],
                                  scanone.perm.imp.all[[i]])), 
         rug = TRUE, 
         labels = NA, 
         title = i) 
}   

growth.plot.2 <-plot_grid( 
  growth.plot[[1]]$plot+theme(legend.position="none"),
  growth.plot[[2]]$plot+theme(legend.position="none"), 
  growth.plot[[3]]$plot+theme(legend.position="none"),
  growth.plot[[4]]$plot+theme(legend.position="none"),
  growth.plot[[5]]$plot+theme(legend.position="none"), 
  growth.plot[[6]]$plot+theme(legend.position="none"),
  growth.plot[[7]]$plot+theme(legend.position="none"),
  growth.plot[[8]]$plot+theme(legend.position="none"),
  growth.plot[[9]]$plot+theme(legend.position="none"),
  growth.plot[[10]]$plot+theme(legend.position="none"),
  # legend, 
  ncol=2, nrow = 5,labels=c("","","",""))  

growth.plot.3 <- plot_grid(growth.plot.2, legend, rel_heights = c(45, 1), ncol = 1, nrow = 2)
growth.plot.3 

ggsave(growth.plot.3, filename = "~/F2/output/QTL_analysis/figure/growth.plot.3.png", width = 12, height = 12)

#### make scanone and CIM plot for each trait 
load("~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")
load("~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.perm.all <- cim.perm
cim.qtl.all <- cim.qtl
scanone.perm.imp.all <- scanone.perm.imp
scanone.imp.all <- scanone.imp

load("~/F2/output/growth_model/scanone_growth_model_trait_flipped.Rdata")
load("~/F2/output/growth_model/cim_growth_model_trait_flipped.Rdata") 

cim.perm.all <- c(cim.perm.all, cim.perm) 
cim.qtl.all <- c(cim.qtl.all, cim_growth_model_trait.F2)
scanone.perm.imp.all <- c(scanone.perm.imp.all[1:43], as.list(lod.thrs[5,]))
scanone.imp.all <- c(scanone.imp.all, scanone_growth_model_trait.F2)

load("~/F2/output/QTL_analysis/cim.qtl.branch.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.perm.branch.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.imp.branch.flipped")
load("~/F2/output/QTL_analysis/scanone.perm.imp.branch.flipped")

cim.perm.all <- c(cim.perm.all, cim.perm[2:4])
cim.qtl.all <- c(cim.qtl.all, cim.qtl[2:4])
scanone.perm.imp.all <- c(scanone.perm.imp.all, scanone.perm.imp[2:4])
scanone.imp.all <- c(scanone.imp.all, scanone.imp[2:4])

save(cim.perm.all, cim.qtl.all, scanone.perm.imp.all, scanone.imp.all, file = "~/F2/output/QTL_analysis/QTL_result_all_all.Rdata") 

qtl_all <-   
  lapply(names(cim.qtl.all), function(trait) {
    qtl_plot(input = rbind(data.frame(cim.qtl.all[[trait]], method = "cim"), 
                       data.frame(scanone.imp.all[[trait]], method = "scanone")),
         lod = data_frame(group = c("cim_threshold", "scanone_threshold"),
                          lod = c(cim.perm.all[[trait]],
                                  scanone.perm.imp.all[[trait]])), 
         rug = TRUE, 
         title = trait
         )  
  }) 

plots <- lapply(1:length(qtl_all), function(trait) qtl_all[[trait]]$plot)

paths <- stringr::str_c(names(cim.qtl.all), ".pdf") 
paths 
pwalk(list(paths, plots), ggsave, path = "~/F2/output/QTL_analysis/new_figure/", width = 15, height = 7) # save on whitney   
```  

### redo QTL analysis for several traits which don't follow normal distribution 
```{r} 
### load data and run scanone & cim
LG.f2.after.crossover <- read.cross("csvsr", genfile = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/LG.f2.madmapper.final_gen_revised_flipped.csv",
                     phefile = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/F2.pheno.csv",
                     genotypes = c("AA", "AB", "BB")) # the only problem is that 44 phenotypes were read instead of 43, need to figure out why later

plot.map(LG.f2.after.crossover)
summaryMap(LG.f2.after.crossover) # 2884

LG.f2.after.crossover <- sim.geno(LG.f2.after.crossover,step=1,n.draws=32) # imputation
LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover,step=1) # calculate the probability of the true underlying genotypes given the observed multipoint marker data --> for each imputed data, give a probability?

LG.f2.after.crossover$pheno %>% colnames() # Caprylic_acid, Myristic_acid, Heptadecanoic_acid, should try "2 part" model in scanone(), Survival_rate use log transformed data to get normality 

scanone_Caprylic <- 
scanone(LG.f2.after.crossover, pheno.col = "Caprylic_acid", method = "em", model = "2part", upper = F)

# permutation 
perm_Caprylic <- 
scanone(LG.f2.after.crossover, pheno.col = "Caprylic_acid", method = "em", model = "2part", upper = F, n.perm = 1000)

summary(perm_Caprylic)[1] # 5.632463 
summary(perm_Caprylic, alpha = 0.05)

plot(scanone_Caprylic,bandcol="gray90", main="Caprylic_acid")
abline(h=summary(perm_Caprylic)[1],lty=2) #add permuation threshold

### Myristic acid 
scanone_Myristic <-
scanone(LG.f2.after.crossover, pheno.col = "Myristic_acid", method = "em", model = "2part", upper = F)

perm_Myristic <-
scanone(LG.f2.after.crossover, pheno.col = "Myristic_acid", method = "em", model = "2part", upper = F, n.perm = 1000) # upper=F to indicate that in the 2part model, phenotype is the smallest observed phenotype 
summary(perm_Myristic)[1] 
summary(perm_Myristic, alpha = 0.05)

plot(scanone_Myristic,bandcol="gray90", main="Myristic_acid")
abline(h=summary(perm_Myristic)[1],lty=2) #add permuation threshold # same result as identified from normal model 

### Heptadecanoic_acid don't worry, to few data points 

### survival rate, transformaion won't work because a lot of 0, is there any other model for survival rate? 
hist(sqrt(LG.f2.after.crossover$pheno$Survival_rate)) 
ggplot(LG.f2.after.crossover$pheno, aes(x = Survival_rate)) + geom_histogram(bins=15) + scale_x_log10() 
min(LG.f2.after.crossover$pheno$Survival_rate, na.rm = T)  

scanone_Survival_rate <-
scanone(LG.f2.after.crossover, pheno.col = "Survival_rate", model = "np")

perm_Survival_rate <-
scanone(LG.f2.after.crossover, pheno.col = "Survival_rate", model = "np", n.perm = 1000) # upper=F to indicate that in the 2part model, phenotype is the smallest observed phenotype 
summary(Survival_rate)[1] 
summary(perm_Survival_rate, alpha = 0.05) 

plot(scanone_Survival_rate,bandcol="gray90", main="Myristic_acid")
abline(h=summary(perm_Survival_rate)[1],lty=2) #add permuation threshold # same result as identified from normal model 

save(scanone_Caprylic, scanone_Myristic, scanone_Survival_rate, perm_Caprylic, perm_Myristic, file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/output/QTL_nonnormality.Rdata") 
```

### table to summarize QTL mapping result, make R square, additive effect... 
```{r}
load("~/F2/output/QTL_analysis/bayesint.list.scanone.cim.Rdata")
length(bayesint.list.scanone) # 33
length(bayesint.list.cim) # 26 

bayesint.result.scanone <- as.tibble(bind_rows(bayesint.list.scanone,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(pos, na.rm = T),end=max(pos, na.rm = T),pos = median(pos, na.rm = T), LOD=max(LOD))  

bayesint.result.scanone %>% dim() # 33 6 

bayesint.result.tmp <- as.tibble(bind_rows(bayesint.list.scanone,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) 

bayesint.result.tmp$index <- paste(bayesint.result.tmp$trait, bayesint.result.tmp$chr, bayesint.result.tmp$LOD)
bayesint.result.scanone$index <- paste(bayesint.result.scanone$trait, bayesint.result.scanone$chr, bayesint.result.scanone$LOD)

test <- 
bayesint.result.tmp %>% 
  anti_join(bayesint.result.scanone) %>% 
  dplyr::select(trait, chr, markername) %>% 
  mutate(index = paste(trait, chr, sep = "_")) 

tmp <- c()
tmp  

for (i in seq_along(1:(nrow(test)/2))){
  tmp[i] <- paste(test$markername[i*2-1], test$markername[i*2-0], sep = "-") 
}

bayesint.result.scanone$index <- tmp

bayesint.result.scanone <- 
bayesint.result.scanone %>%
  mutate(start = round(start, 2), end = round(end, 2), pos = round(pos, 2), LOD = round(LOD, 2)) %>%
  unite(confidence_interval, start, end, sep = "-") %>% 
  mutate(flanking_marker = index) %>% 
  dplyr::select(-index)  

bayesint.result.scanone %>% dim() # 33 6 

### cim result 
bayesint.list.cim %>% length() # 26

bayesint.result <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(pos, na.rm = T),end=max(pos, na.rm = T),pos = median(pos, na.rm = T), LOD=max(LOD)) 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.

bayesint.result %>% dim() # 26 6 
bayesint.result 

bayesint.result.tmp <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) 

bayesint.result.tmp$index <- paste(bayesint.result.tmp$trait, bayesint.result.tmp$chr, bayesint.result.tmp$LOD)
bayesint.result$index <- paste(bayesint.result$trait, bayesint.result$chr, bayesint.result$LOD)

test <- 
bayesint.result.tmp %>% 
  anti_join(bayesint.result) %>% 
  dplyr::select(trait, chr, markername) %>% 
  mutate(index = paste(trait, chr, sep = "_")) 

tmp <- c()
tmp  

for (i in seq_along(1:(nrow(test)/2))){
  tmp[i] <- paste(test$markername[i*2-1], test$markername[i*2-0], sep = "-") 
}

bayesint.result$index <- tmp ##### 

bayesint.result.cim <- 
bayesint.result %>% 
  mutate(start = round(start, 2), end = round(end, 2), pos = round(pos, 2), LOD = round(LOD, 2)) %>%
  unite(confidence_interval, start, end, sep = "-") %>% 
  mutate(flanking_marker = index) %>% 
  dplyr::select(-index)  

bayesint.result.cim %>% dim() # 26 6  

### combine cim & scanone result 
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))
bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))

bayesint.result.paper <- 
bayesint.result.cim %>% 
  full_join(bayesint.result.scanone, by = c("trait", "chr")) 

bayesint.result.paper %>% dim() # 32 12
colnames(bayesint.result.paper)

for (i in 1:nrow(bayesint.result.paper)){
  if(is.na(bayesint.result.paper[i, "pos.x"])){
    bayesint.result.paper[i, c(3:7)] <- bayesint.result.paper[i, c(8:12)]
  }
}

bayesint.result.paper <- bayesint.result.paper[,1:7] 
colnames(bayesint.result.paper) <- gsub("\\.x$", "", colnames(bayesint.result.paper)) 

bayesint.result.paper %>% dim() # 35 7 
bayesint.result.paper %>% View()

save(bayesint.result.paper, file = "~/F2/output/QTL_analysis/bayesint.result.paper.Rdata") 
write.csv(bayesint.result.paper, file = "~/F2/output/QTL_analysis/bayesint.result.paper.csv") 

### re-edit the position according to scantwo result 

### 1) days_to_flower 
# 		fitqtl summary
# 
# Method: multiple imputation 
# Model:  normal phenotype
# Number of observations : 165 
# 
# Full model result
# ----------------------------------  
# Model formula: y ~ Q1 + Q2 
# 
#        df       SS        MS      LOD     %var Pvalue(Chi2)    Pvalue(F)
# Model   4 10800.02 2700.0041 12.45336 29.36008 1.044798e-11 2.055756e-11
# Error 160 25984.69  162.4043                                            
# Total 164 36784.70                                                      
# 
# 
# Drop one QTL at a time ANOVA table: 
# ----------------------------------  
#           df Type III SS   LOD  %var F value Pvalue(Chi2) Pvalue(F)    
# A10@183.9  2        6080 7.533 16.53   18.72            0  4.96e-08 ***
# C06@67.3   2        4264 5.444 11.59   13.13            0  5.26e-06 *** ####### need to change this pos 
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# 
# Estimated effects:
# -----------------
#                  est        SE       t
# Intercept  151.55170   1.01004 150.046 
# A10@183.9a  -7.35767   1.33487  -5.512
# A10@183.9d   4.71660   2.03236   2.321
# C06@67.3a   -7.63332   1.49116  -5.119
# C06@67.3d   -0.09159   2.02693  -0.045

### linolenic acid 
# Full model result
# ----------------------------------  
# Model formula: y ~ Q1 + Q2 + Q1:Q2 
# 
#        df        SS       MS      LOD     %var Pvalue(Chi2) Pvalue(F)
# Model   8 1335.8103 166.9763 66.82275 84.33586            0         0
# Error 157  248.1071   1.5803                                         
# Total 165 1583.9174                                                  
# 
# 
# Drop one QTL at a time ANOVA table: 
# ----------------------------------  
#                    df Type III SS   LOD  %var F value Pvalue(Chi2) Pvalue(F)    
# A08@39.0            6      1183.1 63.17 74.70   124.8            0    <2e-16 ***
# C03@181.0           6      1124.7 61.67 71.01   118.6            0    <2e-16 ***
# A08@39.0:C03@181.0  4       982.3 57.72 62.02   155.4            0    <2e-16 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# 
# Estimated effects:
# -----------------
#                          est      SE       t
# Intercept            10.8127  0.1293  83.606
# A08@39.0a            -0.3259  0.1892  -1.722
# A08@39.0d             1.7490  0.2591   6.752
# C03@181.0a           -0.8086  0.1862  -4.343
# C03@181.0d            0.9781  0.2588   3.779 
# A08@39.0a:C03@181.0a -4.3295  0.2648 -16.349
# A08@39.0d:C03@181.0a  1.3157  0.3739   3.519
# A08@39.0a:C03@181.0d  1.2020  0.3776   3.183
# A08@39.0d:C03@181.0d -0.7604  0.5193  -1.464

### days_to_bolt ### the additional marker is maginal, can add or not, so no need to care about it too much 

# Full model result
# ----------------------------------  
# Model formula: y ~ Q1 + Q2 + Q3 
# 
#        df       SS        MS      LOD    %var Pvalue(Chi2)    Pvalue(F)
# Model   6 11634.05 1939.0081 15.47209 35.0679 2.263745e-13 6.379341e-13
# Error 158 21541.73  136.3401                                           
# Total 164 33175.78                                                     
# 
# 
# Drop one QTL at a time ANOVA table: 
# ----------------------------------  
#           df Type III SS   LOD  %var F value Pvalue(Chi2) Pvalue(F)    
# A10@176.0  2        4731 7.113 14.26  17.350            0  1.54e-07 ***
# C06@85.7   2        3833 5.868 11.55  14.057            0  2.41e-06 ***
# A05@114.0  2        2697 4.227  8.13   9.891            0  8.97e-05 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# 
# Estimated effects:
# -----------------
#                 est       SE       t
# Intercept  119.4954   0.9383 127.351
# A10@176.0a  -7.0704   1.2035  -5.875
# A10@176.0d   1.0081   1.8948   0.532
# C06@85.7a   -7.2351   1.4103  -5.130
# C06@85.7d    2.4429   1.8949   1.289
# A05@114.0a   5.7853   1.3349   4.334
# A05@114.0d  -0.6941   1.9010  -0.365

### linolenic acid, need to be more careful to analyze 

### combine with allele effect information 
bayesint.result.allele_effect <- read.csv("~/F2/output/QTL_analysis/bayesint.result.paper_allele_effect.csv")
bayesint.result.allele_effect %>% dim()
bayesint.result.paper %>% dim()

bayesint.result.paper.final <- 
bayesint.result.paper %>%
  left_join(bayesint.result.allele_effect, by = c("trait", "chr")) %>% 
  mutate(model = model.x) %>%
  dplyr::select(-model.x, -model.y, -X) 

bayesint.result.paper.final %>% View()
write.csv(bayesint.result.paper.final, file = "~/F2/output/QTL_analysis/bayesint.result.paper.final.csv")  

### add physical position interval  
load("~/F2/output/QTL_analysis/bayesint.list.scanone.cim.Rdata")
length(bayesint.list.scanone) # 33
length(bayesint.list.cim) # 26 

bayesint.result.scanone <- as.tibble(bind_rows(bayesint.list.scanone,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD))

bayesint.result.cim <- as.tibble(bind_rows(bayesint.list.cim,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD))

bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))

bayesint.result <- 
bayesint.result.cim %>% 
  full_join(bayesint.result.scanone, by = c("trait", "chr")) 

bayesint.result %>% dim()
colnames(bayesint.result)

for (i in 1:nrow(bayesint.result)){
  if(is.na(bayesint.result[i, "start.x"])){
    bayesint.result[i, c(3:7)] <- bayesint.result[i, c(8:12)]
  }
}

bayesint.result <- bayesint.result[,1:7] 
colnames(bayesint.result) <- gsub("\\.x$", "", colnames(bayesint.result)) 

bayesint.result %>% dim() # 35 7 
bayesint.result %>% View()
save(bayesint.result, file = "~/F2/for_paper/synteny_analysis/bayesint.result.physical.Rdata") 

bayesint.result.physical <-
bayesint.result.paper.final %>% 
  left_join(bayesint.result, by= c("trait", "chr")) %>% 
  mutate(model = model.x) %>% 
  dplyr::select(-min_eQTL_LOD, -max_eQTL_LOD, -model.y, -model.x) 
  
write.csv(bayesint.result.physical, file = "~/F2/output/QTL_analysis/bayesint.result.paper.physical.csv") 
```

### QTL analysis of branch data and new leaf K data 
```{r}
### load data and run scanone & cim
LG.f2.after.crossover <- read.cross("csvsr", genfile = "~/F2/data/QTL_analysis/LG.f2.madmapper.final_gen_revised_flipped.csv",
                     phefile = "~/F2/for_paper/branch_data/phefile.branch.csv", 
                     genotypes = c("AA", "AB", "BB")) # the only problem is that 44 phenotypes were read instead of 43, need to figure out why later

plot.map(LG.f2.after.crossover)
map.summary <- summaryMap(LG.f2.after.crossover) # 2884

LG.f2.after.crossover <- sim.geno(LG.f2.after.crossover,step=1,n.draws=32) # imputation
LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover,step=1) # calculate the probability of the true underlying genotypes given the observed multipoint marker data --> for each imputed data, give a probability?

sfInit(parallel = TRUE, cpus = 4)
sfExport("LG.f2.after.crossover") 
sfLibrary(qtl)

system.time(
scanone.perm.imp <-
  sfLapply(seq_along(LG.f2.after.crossover$pheno), function(trait){
    print(trait) # print doesn't work in here
    tmp <-scanone(LG.f2.after.crossover,pheno.col = trait, method="imp",n.perm=1000, n.cluster = 16)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes 40 mins to finish
)
sfStop()

names(scanone.perm.imp) <- colnames(LG.f2.after.crossover$pheno)
save(scanone.perm.imp, file = "~/F2/output/QTL_analysis/scanone.perm.imp.branch.flipped")

# Erucic acid 
scanone.imp.Erucic <- scanone(LG.f2.after.crossover,pheno.col=5,method="imp") #
plot(scanone.imp.Erucic,bandcol="gray90", main="Erucic_acid")

system.time(
scanone.imp <-
lapply(seq_along(LG.f2.after.crossover$pheno[1:4]), function(trait) {
  print(trait)
  scanone(LG.f2.after.crossover,pheno.col=trait,method="imp")
})
)
names(scanone.imp) <- colnames(LG.f2.after.crossover$pheno)[1:4]

png("~/F2/for_paper/branch_data/QTL_one_dim_flipped.png", width=25, height=15, units="in", res=300)
par(mfrow=c(1,4))

for (i in names(scanone.imp)){
  plot(scanone.imp[[i]],bandcol="gray90", main=i)
  abline(h=scanone.perm.imp[[i]],lty=2)
}

dev.off()

save(scanone.imp, file = "~/F2/output/QTL_analysis/scanone.imp.branch.flipped")

cim.qtl <-
lapply(seq_along(LG.f2.after.crossover$pheno)[1:4], function(trait) {
  print(trait)
  cim(LG.f2.after.crossover, n.marcovar=5, pheno.col=trait,method="em")
})

# here we use the interval mapping method "em" as this is how cim was originaly implmented.the n.marcovar= argument defines the maximum number of marker covariates to use.
names(cim.qtl) <- colnames(LG.f2.after.crossover$pheno)[1:4]

sfInit(parallel = TRUE, cpus = 4)
sfExport("LG.f2.after.crossover")
sfLibrary(qtl)

cim.perm <-
  sfLapply(seq_along(LG.f2.after.crossover$pheno)[1:4], function(trait){
    message(trait) # message doesn't work in here either
    tmp <- cim(LG.f2.after.crossover,
               pheno.col = trait,
               n.marcovar=5,
               method="em",
               n.perm=1000)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes almost 4 hours to finish

sfStop() 

names(cim.perm) <- colnames(LG.f2.after.crossover$pheno)[1:4]

###### down to here... 

# plot out result and save plot
png("~/F2/output/QTL_analysis/figure/QTL_cim_1_flipped_branch.png", width=25, height=15, units="in", res=300)
par(mfrow=c(1,4))

for (i in names(cim.qtl)){
  plot(cim.qtl[[i]],bandcol="gray90", main=i)
  abline(h=cim.perm[[i]],lty=2) 
} 

dev.off() 
# more QTL found for cim method

save(cim.qtl, file = "~/F2/output/QTL_analysis/cim.qtl.branch.flipped.Rdata")
save(cim.perm, file = "~/F2/output/QTL_analysis/cim.perm.branch.flipped.Rdata")  
```

visualize QTL result from the two major loci 
```{r}
load("~/F2/output/QTL_analysis/QTL_result_all.Rdata")
scanone.perm.imp.all %>% length() # 51 
scanone.imp.all %>% length() 
cim.perm.all %>% length()
cim.qtl.all %>% length()

names(scanone.imp.all) 

# extract scanone result for 
load("~/F2/for_paper/synteny_analysis/bayesint.result.physical.Rdata")

bayesint.result_scanone <- 
bayesint.result %>% 
  filter(model == "scanone")  

bayesint.result_scanone
scanone_result <- list()

for (i in 1:nrow(bayesint.result_scanone)) {
  trait <- bayesint.result_scanone$trait[i] 
  chr1 <- bayesint.result_scanone$chr[i] 
  tmp <- scanone.imp.all[[trait]] 
  scanone_result[[i]] <- tmp %>% filter(chr == chr1) 
}

names(scanone_result) <- bayesint.result_scanone$trait

bayesint.result_cim <- 
bayesint.result %>% 
  filter(model == "cim")  

bayesint.result_cim
cim_result <- list()

for (i in 1:nrow(bayesint.result_cim)) {
  trait <- bayesint.result_cim$trait[i] 
  chr1 <- bayesint.result_cim$chr[i] 
  tmp <- cim.qtl.all[[trait]] 
  cim_result[[i]] <- tmp %>% filter(chr == chr1) 
}

names(cim_result) <- bayesint.result_cim$trait
cim_result[[1]] 

# combine result and plot 
# add model label 
for(i in 1:length(scanone_result)){
  scanone_result[[i]]$model <- rep("scanone", nrow(scanone_result[[i]]))
  scanone_result[[i]]$trait <- rep(names(scanone_result)[i], nrow(scanone_result[[i]]))
}

for(i in 1:length(cim_result)){
  cim_result[[i]]$model <- rep("cim", nrow(cim_result[[i]]))
  cim_result[[i]]$trait <- rep(names(cim_result)[i], nrow(cim_result[[i]]))
}

scanone <- 
lapply(1:length(scanone_result), function(i) {
  tmp <- scanone_result[[i]] %>% 
    filter(chr == "A08" | chr == "C03")
  if(nrow(tmp) > 0){
    tmp
  }
})

cim <- 
lapply(1:length(cim_result), function(i) {
  tmp <- cim_result[[i]] %>% 
    filter(chr == "A08" | chr == "C03")
    if(nrow(tmp) > 0){
    tmp
    }
})

final_FA <- do.call(rbind, plyr::compact(c(scanone, cim))) 

# p.final_FA <-
final_FA %>% 
  ggplot() +
  geom_tile(color = "white", aes(x = factor(pos), y = trait, fill=log10(lod))) +  scale_fill_gradient2(low=("green"), high=("magenta")) +
  facet_grid(trait~chr, scales = "free") + 
  labs(y = "", x="genetic position", title="Fatty acid major QTL") + 
  theme_bw() +
  theme(axis.text.x=element_blank(), strip.text.y = element_blank(), plot.title = element_text(hjust = 0.5))   

# flower etc. 
scanone_2 <- 
lapply(1:length(scanone_result), function(i) {
  tmp <- scanone_result[[i]] %>% 
    filter(chr == "A10" | chr == "C06")
  if(nrow(tmp) > 0){
    tmp
  }
})

cim_2 <- 
lapply(1:length(cim_result), function(i) { 
  tmp <- cim_result[[i]] %>% 
    filter(chr == "A10" | chr == "C06")
    if(nrow(tmp) > 0){
    tmp
    }
})

final_flower_etc <- do.call(rbind, plyr::compact(c(scanone_2, cim_2))) 

# p.flower_etc <-
final_flower_etc %>%  
  filter(trait != "Myristic_acid") %>% 
  ggplot() +
  geom_tile(color = "white", aes(x = factor(pos), y = trait, fill=lod, linetype = model)) + scale_fill_gradient2(low=("green"), high=("magenta")) +
  facet_grid(trait~chr, scales = "free") + 
  labs(y = "", x="genetic position", title="flowering time and growth-related traits major QTL") + 
  theme_bw() +
  theme(axis.text.x=element_blank(), strip.text.y = element_blank(), plot.title = element_text(hjust = 0.5)) 

ggsave(p.flower_etc, filename = "~/F2/for_paper/flower_etc.png", height = 3, width = 9)
ggsave(p.final_FA, filename = "~/F2/for_paper/FA.png", height = 3, width = 9) 
```

### get SNP information for genes underneath the QTL interval, those with missense & stop gained mutation  

also check the result in SNP between Da-Ae and Da-Ol-1 no matter whether they have decent coverage or not in late silique, this result looks better, use this result 

```{r}
SNP_all <-  read.csv("~/F2/for_paper/candidate_gene_SNP_mutation/vcf.Ae.Ol.intersect.df.2.csv", row.names = 1, as.is = T)
SNP_all %>% head()  

SNP_all <- data.frame(sapply(SNP_all, function(i) sub("1-Jan", "1/1", i))) %>% 
  dplyr::select(-subgenome, -Chr_ID)

write.csv(SNP_all, file = "~/F2/for_paper/candidate_gene_SNP_mutation/SNP_all.csv")

# sh ~/KIAT/F2/SNP_info_extract_vcf_ann.sh ~/F2/for_paper/candidate_gene_SNP_mutation/SNP_late_silique.csv /Network/Servers/avalanche.plb.ucdavis.edu/Volumes/Mammoth/Users/ruijuanli/SNP_parent/result/freebayes/Ae_Ol_modified_SNPonly_biallelic.recode.ann.modified2.vcf 

sig_SNP_ann <- read_table2("~/KIAT/F2/significant_SNP_annotation", col_names=F)
head(sig_SNP_ann)  
dim(sig_SNP_ann) # 62875     6 
colnames(sig_SNP_ann) <- c("CHROM", "POS", "REF", "ALT", "mutation_type", "impact")

SNP_all$POS <- SNP_all$POS %>% as.character() %>% as.numeric()
# SNP_all$CHROM <- as.character(SNP_all$CHROM)
# SNP_all$REF <- as.character(SNP_all$REF)
# SNP_all$ALT <- as.character(SNP_all$ALT)
# str(SNP_all)

SNP_all <- 
SNP_all %>% 
  left_join(sig_SNP_ann)

gff.mRNA <- read.table("~/Reference/B.napus/gff.mRNA")
dim(gff.mRNA) # 101040      4 
head(gff.mRNA) 
colnames(gff.mRNA) <- c("CHROM", "start", "end", "name") 

genes <- GRanges(seqnames = Rle(gff.mRNA$CHROM),ranges = IRanges(start = gff.mRNA$start, end = gff.mRNA$end), names = gff.mRNA$name)
genes 

SNP <- GRanges(seqnames = Rle(sig_SNP_ann$CHROM), ranges = IRanges(start = sig_SNP_ann$POS, end = sig_SNP_ann$POS), ID = paste(sig_SNP_ann$CHROM, sig_SNP_ann$POS, sep = "_"))
SNP

SNP_gene <- mergeByOverlaps(SNP, genes) # warning message here. look out!!!!!! 
SNP_gene

SNP_gene_df <- as.data.frame(SNP_gene)
SNP_gene_df %>% dim() # 58969    14

SNP_gene_final <- SNP_gene_df[,c("SNP.ID", "genes.seqnames", "SNP.start", "names")]

SNP_all$SNP.ID <- paste(SNP_all$CHROM, SNP_all$POS, sep = "_") 

SNP_all <- 
SNP_all %>% 
  left_join(SNP_gene_final)

dim(SNP_all) #  62958    12

unique(SNP_all$mutation_type) 

# the kind of mutations that could affect protein function here: "missense_variant&splice_region_variant", "missense_variant", "stop_lost", "splice_region_variant&synonymous_variant", "splice_donor_variant&intron_variant", "splice_region_variant&intron_variant", "stop_gained&splice_region_variant", "splice_acceptor_variant&intron_variant", "stop_lost&splice_region_variant", "splice_region_variant&stop_retained_variant", "initiator_codon_variant", "start_lost"  

# combine mutation type with candidate genes 
SNP_all %>% colnames()

load("~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata")
traitQTL.annotated %>% colnames() 

traitQTL.annotated <- 
traitQTL.annotated %>% 
  semi_join(SNP_all, c("gene_ID" = "names")) %>% # keep all genes which have SNP annotations 
  left_join(SNP_all, c("gene_ID" = "names"))   # add SNP info/annotation to the QTL gene

dim(traitQTL.annotated) # 9730 

# just keep mutations which would affect protein function
traitQTL.annotated.SNP <- 
traitQTL.annotated %>% 
  filter(mutation_type != "synonymous_variant" & 
           mutation_type != "downstream_gene_variant" & 
           mutation_type != "upstream_gene_variant" & 
           mutation_type != "intron_variant" & 
           mutation_type != "stop_retained_variant") %>% 
  dplyr::select(trait, SNP.ID, mutation_type, impact, gene_ID, AGI, At_symbol, B.napus_GO_term, GO_des) 

dim(traitQTL.annotated.SNP) # 4062 
traitQTL.annotated.SNP$gene_ID %>% unique() %>% length() # 973 
write.csv(traitQTL.annotated.SNP, file = "~/F2/for_paper/candidate_gene_SNP_mutation/traitQTL.annotated.SNP.csv")  
```   

when filtered by F2 SNPs, didn't use this result for final report 
```{r}
F2_geno_data <- read.table("~/F2/for_paper/candidate_gene_SNP_mutation/F2_Final_SNP_Calls", header = T)
head(F2_geno_data) 
dim(F2_geno_data) # 18226   172  

SNP_late_silique <- 
F2_geno_data %>% 
  dplyr::select(CHROM:Ol.gt) 

write.csv(SNP_late_silique, file = "~/F2/for_paper/candidate_gene_SNP_mutation/SNP_late_silique.csv")

# sh ~/KIAT/F2/SNP_info_extract_vcf_ann.sh ~/F2/for_paper/candidate_gene_SNP_mutation/SNP_late_silique.csv /Network/Servers/avalanche.plb.ucdavis.edu/Volumes/Mammoth/Users/ruijuanli/SNP_parent/result/freebayes/Ae_Ol_modified_SNPonly_biallelic.recode.ann.modified2.vcf

sig_SNP_ann <- read_table2("~/F2/for_paper/candidate_gene_SNP_mutation/significant_SNP_annotation", col_names=F)

head(sig_SNP_ann)  
dim(sig_SNP_ann) 
colnames(sig_SNP_ann) <- c("CHROM", "POS", "REF", "ALT", "mutation_type", "impact")

SNP_late_silique <- 
SNP_late_silique %>% 
  left_join(sig_SNP_ann)  

gff.mRNA <- read.table("~/Reference/B.napus/gff.mRNA")
dim(gff.mRNA) # 101040      4 
head(gff.mRNA) 
colnames(gff.mRNA) <- c("CHROM", "start", "end", "name") 

genes <- GRanges(seqnames = Rle(gff.mRNA$CHROM),ranges = IRanges(start = gff.mRNA$start, end = gff.mRNA$end), names = gff.mRNA$name)
genes 

SNP <- GRanges(seqnames = Rle(sig_SNP_ann$CHROM), ranges = IRanges(start = sig_SNP_ann$POS, end = sig_SNP_ann$POS), ID = paste(sig_SNP_ann$CHROM, sig_SNP_ann$POS, sep = "_"))
SNP

SNP_gene <- mergeByOverlaps(SNP, genes) # warning message here. look out!!!!!! 
SNP_gene

SNP_gene_df <- as.data.frame(SNP_gene)
SNP_gene_df %>% dim() # 17315    14 

SNP_gene_final <- SNP_gene_df[,c("SNP.ID", "genes.seqnames", "SNP.start", "names")]

SNP_late_silique$SNP.ID <- paste(SNP_late_silique$CHROM, SNP_late_silique$POS, sep = "_") 

SNP_late_silique <- 
SNP_late_silique %>% 
  left_join(SNP_gene_final)

dim(SNP_late_silique) # 18226     12

unique(SNP_late_silique$mutation_type)

# the kind of mutations that could affect protein function here: "missense_variant&splice_region_variant", "missense_variant", "stop_lost", "splice_region_variant&synonymous_variant", "splice_donor_variant&intron_variant", "splice_region_variant&intron_variant", "stop_gained&splice_region_variant", "splice_acceptor_variant&intron_variant", "stop_lost&splice_region_variant", "splice_region_variant&stop_retained_variant", "initiator_codon_variant", "start_lost"  

# combine mutation type with candidate genes 
SNP_late_silique %>% colnames()

load("~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata")
traitQTL.annotated %>% colnames() 

test <- 
traitQTL.annotated %>% 
  semi_join(SNP_late_silique, c("gene_ID" = "names")) %>% # keep all genes which have SNP annotations 
  left_join(SNP_late_silique, c("gene_ID" = "names"))  # add SNP info/annotation to the QTL gene
#  dplyr::select(-genes.seqnames, -SNP.start, -genetic_start, -genetic_end, -CHROM, -POS, -start, -end, -B.napus_GO_term, -subject, -REF, -ALT) %>% 
#  View() 

test[grep("lipid|fatty", test$GO_des),] %>%
dplyr::select(-genes.seqnames, -SNP.start, -genetic_start, -genetic_end, -CHROM, -POS, -start, -end, -B.napus_GO_term, -subject, -REF, -ALT) %>%
View() 
test$gene_ID %>% unique() %>% length() 
```
















