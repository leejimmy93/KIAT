---
title: "505_network_WGCNA"
output: html_document
---

purpose of this script is to do WGCNA network anaysis using 505 SNP data. 

I did network analysis for our 414 F2 population using SNP data (https://github.com/leejimmy93/KIAT/blob/master/F2/F2_network.Rmd & https://github.com/leejimmy93/KIAT/blob/master/F2/F2_network_batch_corrected.Rmd), however, the identified gene co-expression modules correlated with different traits seems to arise from the genetic linkage instead of expression, so we want to see whether we have the same problem for 505. 

### load libs
```{r}
library(WGCNA) 
library(tidyverse) 
library(edgeR) 
library(DESeq2)
library(magrittr) 
library(gplots) 
library(reshape2)
library(sva) 
options(stringsAsFactors = FALSE) 
```

### load expression data, normalize, and correct for batch effect 
```{r}
# load data 
read_count_505 <- read.table("~/505/data/late_silique/read.count.505.tsv", header=T, row.names=1)
dim(read_count_505) # 101040    131 
read_count_505[1:10, 1:10]

# filter low expression tags 
keep <- rowSums(cpm(read_count_505) > 1) >= (131 * 0.25) # 1cpm in at least 1/4 of the samples 
read_count_505 <- read_count_505[keep,]
dim(read_count_505) # 49038   131

colnames(read_count_505) <- gsub("Sample_", "", colnames(read_count_505))
colnames(read_count_505) <- gsub("\\.", "\\-", colnames(read_count_505))

# add batch information 
sample_des_c <- read.csv("~/505/data/phenotype/batch_c.csv", stringsAsFactors=F, header=T, na.strings = "")
sample_des_d <- read.csv("~/505/data/phenotype/batch_d.csv", stringsAsFactors=F, header=T, na.strings = "")
sample_des_e <- read.csv("~/505/data/phenotype/batch_e.csv", stringsAsFactors=F, header=T, na.strings = "")

batch_info <- data.frame(batch = c(rep("C", nrow(sample_des_c)), 
                                  rep("D", nrow(sample_des_d)), 
                                  rep("E", nrow(sample_des_e))), 
                         sample_ID = c(sample_des_c$Sample.ID, sample_des_d$Sample.ID, sample_des_e$Sample.ID))

batch_info <- batch_info[match(colnames(read_count_505), batch_info$sample_ID),] 
all(batch_info$sample_ID == colnames(read_count_505)) # True 

# sample description 
sample.505 <- data.frame(batch = factor(batch_info$batch), 
                        genotype = factor(batch_info$sample_ID))

# vst transformation 
dds.505 <- DESeqDataSetFromMatrix(countData = round(read_count_505), 
                                  colData = sample.505, 
                                  design = ~genotype)

vsd.505 <- varianceStabilizingTransformation(dds.505)
vstMat.505 <- assay(vsd.505)
colnames(vstMat.505) <- colnames(read_count_505) 

# MDS to check batch effect 
vstMat.505 %>% dim() #  49038   131
test1 <- as.matrix(dist(t(vstMat.505)))  

test2 <- as.data.frame(cmdscale(test1))
head(test2) #now we have 2 dimensions 
plot(test2)
test2$sample_ID <- rownames(test2)
test2 %>% 
  left_join(batch_info, by = "sample_ID") %>% 
  ggplot() + 
  geom_point(aes(x = V1, y= V2, color = as.factor(batch))) # looks like there is batch effect on PC2

# correct batch effect 
vstMat.505.batch.corrected <- removeBatchEffect(vstMat.505, batch = batch_info$batch) 
test1 <- as.matrix(dist(t(vstMat.505.batch.corrected)))  
test2 <- as.data.frame(cmdscale(test1))
test2$sample_ID <- rownames(test2)
test2 %>% 
  left_join(batch_info, by = "sample_ID") %>% 
  ggplot() + 
  geom_point(aes(x = V1, y= V2, color = as.factor(batch))) # great, batch effect removed

# get genes with large variation across samples using variance, The variance is a numerical measure of how the data values is dispersed around the mean.
# https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/faq.html

vstMat.505.batch.corrected <- as.data.frame(vstMat.505.batch.corrected)
vstMat.505.batch.corrected$variance <- as.numeric(apply(vstMat.505.batch.corrected,1,var))  
summary(vstMat.505.batch.corrected$variance) 

vstMat.505.batch.corrected.largeVar<-
  vstMat.505.batch.corrected %>% 
  filter(variance>1) %>% # dispersed one reads arround the mean 
  dplyr::select(-variance) 

dim(vstMat.505.batch.corrected.largeVar) # 14264   132   

save(vstMat.505.batch.corrected.largeVar, file = "~/505/network_analysis/output/vstMat.505.batch.corrected.largeVar.Rdata")
```

### 1) follow Julin's method for network analysis 

### WGCNA for network
```{r}
enableWGCNAThreads()

load("~/505/network_analysis/output/vstMat.505.batch.corrected.largeVar.Rdata")  
vstMat.505.WGCNA <- vstMat.505.batch.corrected.largeVar
dim(vstMat.505.WGCNA)

# transform expression data 
head(vstMat.505.WGCNA[,1:6])
vstMat.505.WGCNA.t <- t(vstMat.505.WGCNA)
head(vstMat.505.WGCNA.t[,1:6]) 

# check sample quality 
gag.CR <- goodSamplesGenes(vstMat.505.WGCNA.t, verbose = 3)
gag.CR$allOK

# cluster samples to look for outliers
sampleTREE.CR <- hclust(dist(vstMat.505.WGCNA.t), method = "average")
plot(sampleTREE.CR,cex=.6) # should be able to color based on batch, see whether outliers are due to batch effect 
# heatmap.2(vstMat.f2.A.WGCNA.t,Rowv=as.dendrogram(sampleTREE.CR), scale="col", trace="none")
# are there spurious sample that seem different from other samples? outliers? 

# soft threshold:  In an unsigned coexpression network, modules correspond to clusters of genes with high absolute correlations. In a signed network, modules correspond to positively correlated genes.
powers <- c(c(1:10), seq(from = 12, to=30, by=2))
sft <- pickSoftThreshold(vstMat.505.WGCNA.t, powerVector = powers, verbose = 5, networkType = "unsigned")

sizeGrWindow(9, 5)
par(mfrow = c(1,2)) 
cex1 <- 0.9 
# Scale-free topology fit index as a fCRction of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red")
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a fCRction of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red") 
# For this unsigned networks, while I didn't get plautea but 6 is the suggested power to use and it gives me high R squared to fit a scale free network model. 

# choose 6 
softPower <- 6
adjacency <- adjacency(vstMat.505.WGCNA.t, power = softPower)
# Turn adjacency into topological overlap, topological overlap leads to a network distance measure
dim(adjacency) # 14264 14264
TOM <- TOMsimilarity(adjacency); # add system.time() here next time. Calculation of the topological overlap matrix from a given adjacency matrix. 
dissTOM <- 1-TOM

# Call the hierarchical clustering fCRction
geneTree <- hclust(as.dist(dissTOM), method = "average")
# Plot the resulting clustering tree (dendrogram)
sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)

# define modules 
# We like large modules, so we set the minimum module size relatively high:
minModuleSize <- 30;
# Module identification using dynamic tree cut:
dynamicMods <- cutreeDynamic(dendro = geneTree, distM = dissTOM,
                             deepSplit <- 2, pamRespectsDendro = FALSE,
                             minClusterSize = minModuleSize);
table(dynamicMods)
table(dynamicMods) %>% length() # 56 modules 

# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Plot the dendrogram and colors CRderneath
sizeGrWindow(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")

# merge similar modules
# Calculate eigengenes 
MEList <- moduleEigengenes(vstMat.505.WGCNA.t, colors = dynamicColors) # Calculates module eigengenes (1st principal component) of modules in a given single dataset. 
MEs <- MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss <- 1-cor(MEs);
# Cluster module eigengenes
METree <- hclust(as.dist(MEDiss), method = "average");
# Plot the result
sizeGrWindow(7, 6)
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")

# merge with correlation > 0.8

MEDissThres = 0.2
# Plot the cut line into the dendrogram
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")
abline(h=MEDissThres, col = "red")
# Call an automatic merging fCRction
merge = mergeCloseModules(vstMat.505.WGCNA.t, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs

# compare pre and post merge

sizeGrWindow(12, 9)
#pdf(file = "Plots/geneDendro-3.pdf", wi = 9, he = 6)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
#dev.off()

# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs

save(MEs, file = "~/505/network_analysis/output/MEs_505.Rdata")
```

### GO enrichment of all modules 
```{r}

```

### related modules to trait and identify important genes 
```{r}

```

### get eigene gene QTL 
```{r}

```

### analyze eigenegene QTL 
```{r}

```








